// Generated by CoffeeScript 1.6.3
var JsonValidator, ValidationErrors, amanda, crypto, errors, json_schema_options, sylables,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

amanda = require('amanda');

crypto = require('crypto');

ValidationErrors = require('./validation-errors').ValidationErrors;

errors = require('../errors');

sylables = ['a', 'e', 'i', 'o', 'u'];

json_schema_options = {
  singleError: false,
  messages: {
    'minLength': function(prop, val, validator) {
      return "The <code>" + prop + "</code> property must be at least <code>" + validator + "</code> characters long (currently <code>" + val.length + "</code> characters long).";
    },
    'maxLength': function(prop, val, validator) {
      return "The <code>" + prop + "</code> property must not exceed <code>" + validator + "</code> characters (currently <code>" + val.length + "</code> characters long).";
    },
    'length': function(prop, val, validator) {
      return "The <code>" + prop + "</code> property must be exactly <code>" + validator + "</code> characters long (currently <code>" + val.length + "</code> characters long).";
    },
    'format': function(prop, val, validator) {
      var _ref;
      return "The <code>" + prop + "</code> property must be " + ((_ref = validator[0].toLowerCase(), __indexOf.call(sylables, _ref) >= 0) ? 'an' : 'a') + " <code>" + validator + "</code> (current value is <code>" + (JSON.stringify(val)) + "</code>).";
    },
    'type': function(prop, val, validator) {
      var _ref;
      return "The <code>" + prop + "</code> property must be " + ((_ref = validator[0].toLowerCase(), __indexOf.call(sylables, _ref) >= 0) ? 'an' : 'a') + " <code>" + validator + "</code> (current value is <code>" + (JSON.stringify(val)) + "</code>).";
    },
    'except': function(prop, val, validator) {
      return "The <code>" + prop + "</code> property must not be <code>" + val + "</code>.";
    },
    'minimum': function(prop, val, validator) {
      return "The minimum value of the <code>" + prop + "</code> must be <code>" + validator + "</code> (current value is <code>" + (JSON.stringify(val)) + "</code>).";
    },
    'maximum': function(prop, val, validator) {
      return "The maximum value of the <code>" + prop + "</code> must be <code>" + validator + "</code> (current value is <code>" + (JSON.stringify(val)) + "</code>).";
    },
    'pattern': function(prop, val, validator) {
      return "The <code>" + prop + "</code> value (<code>" + val + "</code>) does not match the <code>" + validator + "</code> pattern.";
    },
    'maxItems': function(prop, val, validator) {
      return "The <code>" + prop + "</code> property must not contain more than <code>" + validator + "</code> items (currently contains <code>" + val.length + "</code> items).";
    },
    'minItems': function(prop, val, validator) {
      return "The <code>" + prop + "</code> property must contain at least <code>" + validator + "</code> items (currently contains <code>" + val.length + "</code> items).";
    },
    'divisibleBy': function(prop, val, validator) {
      return "The <code>" + prop + "</code> property is not divisible by <code>" + validator + "</code> (current value is <code>" + (JSON.stringify(val)) + "</code>).";
    },
    'uniqueItems': function(prop, val, validator) {
      return "All items in the <code>" + prop + "</code> property must be unique.";
    }
  }
};

JsonValidator = JsonValidator = (function() {
  function JsonValidator(_arg) {
    var data, error, outError, schema;
    data = _arg.data, schema = _arg.schema;
    try {
      if (typeof data !== 'object') {
        throw new Error('input data is not object');
      }
      this.data = JSON.parse(JSON.stringify(data));
    } catch (_error) {
      error = _error;
      outError = new errors.DataNotJsonParsableError('JSON validator: ' + error.message);
      outError['data'] = data;
      throw outError;
    }
    try {
      if (typeof schema !== 'object') {
        throw new Error('input schema is not object');
      }
      this.schema = JSON.parse(JSON.stringify(schema));
    } catch (_error) {
      error = _error;
      outError = new errors.SchemaNotJsonParsableError('JSON validator: ' + error.message);
      outError['schema'] = schema;
      throw outError;
    }
  }

  JsonValidator.prototype.validate = function() {
    var dataHash, error, schemaHash;
    if ((typeof this.data === 'object' && Object.keys(this.data).length === 0) || (typeof this.data === 'object' && this.schema['empty'])) {
      error = {
        "length": 0,
        "errorMessages": {}
      };
      return new ValidationErrors(error);
    }
    dataHash = this.getHash(this.data);
    schemaHash = this.getHash(this.schema);
    if (this.dataHash === dataHash && this.schemaHash === schemaHash) {
      return this.errors;
    } else {
      this.dataHash = dataHash;
      this.schemaHash = schemaHash;
    }
    return this.validatePrivate();
  };

  JsonValidator.prototype.validatePrivate = function() {
    var error,
      _this = this;
    try {
      return amanda.validate(this.data, this.schema, json_schema_options, function(error) {
        return _this.errors = new ValidationErrors(error);
      });
    } catch (_error) {
      error = _error;
      error = {
        "0": {
          "property": [],
          "attributeValue": true,
          "message": "Validator internal error: " + error.message,
          "validatorName": "error"
        },
        "length": 1,
        "errorMessages": {}
      };
      return this.errors = new ValidationErrors(error);
    }
  };

  JsonValidator.prototype.getHash = function(data) {
    return crypto.createHash('md5').update(JSON.stringify(data)).digest('hex');
  };

  return JsonValidator;

})();

module.exports = {
  JsonValidator: JsonValidator
};
